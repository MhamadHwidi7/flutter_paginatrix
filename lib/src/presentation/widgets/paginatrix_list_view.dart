import 'package:flutter/material.dart';
import 'package:flutter_paginatrix/flutter_paginatrix.dart';
import 'package:flutter_paginatrix/src/core/mixins/paginatrix_state_builder_mixin.dart';

/// ListView adapter for Paginatrix using BlocBuilder
///
/// This widget uses [PaginatrixCubit] with BlocBuilder for reactive UI updates.
///
/// ## Scroll Direction & Reverse
///
/// When using [reverse] with [scrollDirection]:
/// - **Vertical + reverse**: List scrolls from bottom to top (chat-like)
/// - **Horizontal + reverse**: List scrolls from right to left (RTL-like)
/// - Both combinations are valid but have different UX implications
///
/// ## Example
///
/// ```dart
/// final pagination = PaginatrixController<Pokemon>(
///   loader: repository.loadPokemon,
///   itemDecoder: Pokemon.fromJson,
///   metaParser: ConfigMetaParser(MetaConfig.nestedMeta),
/// );
///
/// PaginatrixListView<Pokemon>(
///   controller: pagination,
///   itemBuilder: (context, pokemon, index) {
///     return PokemonCard(pokemon: pokemon);
///   },
/// )
/// ```
///
/// **Note:** You can use either `controller` or `cubit` parameter.
/// `PaginatrixController` is the recommended public API and doesn't
/// require importing `flutter_bloc` directly.
///
/// ## Parameters
///
/// - `controller` or `cubit` - The pagination controller (required, one of them)
/// - [itemBuilder] - Function to build each item widget (required)
/// - [keyBuilder] - Optional function to generate keys for items
/// - [prefetchThreshold] - Number of items from end to trigger next page load
/// - [padding] - Padding around the list
/// - [physics] - Scroll physics behavior
/// - [shrinkWrap] - Whether the list should shrink-wrap its contents
/// - [scrollDirection] - Scroll direction (vertical or horizontal)
/// - [reverse] - Whether to reverse the scroll direction
/// - [separatorBuilder] - Optional builder for separators between items
/// - [skeletonizerBuilder] - Custom skeleton loader for initial state
/// - [emptyBuilder] - Custom widget for empty state
/// - [errorBuilder] - Custom widget for error state
/// - [appendErrorBuilder] - Custom widget for append error state
/// - [appendLoaderBuilder] - Custom widget for loading more indicator
/// - [onPullToRefresh] - Callback when user pulls to refresh
/// - [onRetryInitial] - Callback for retrying initial load
/// - [onRetryAppend] - Callback for retrying append operation
/// - [endOfListMessage] - Custom message when no more items are available
/// - [addAutomaticKeepAlives] - Whether to add automatic keep-alives
/// - [addRepaintBoundaries] - Whether to add repaint boundaries
/// - [addSemanticIndexes] - Whether to add semantic indexes
/// - [cacheExtent] - Cache extent for the scroll view
class PaginatrixListView<T> extends StatelessWidget
    with PaginatrixStateBuilderMixin<T> {
  /// Creates a [PaginatrixListView] widget.
  ///
  /// The [controller] or [cubit] parameter is required to provide pagination state.
  /// The [itemBuilder] is required to build each item in the list.
  PaginatrixListView({
    super.key,
    PaginatrixCubit<T>? cubit,
    PaginatrixController<T>? controller,
    required this.itemBuilder,
    this.keyBuilder,
    this.prefetchThreshold,
    this.padding,
    this.physics,
    this.shrinkWrap = false,
    this.scrollDirection = Axis.vertical,
    this.reverse = false,
    this.separatorBuilder,
    this.skeletonizerBuilder,
    this.emptyBuilder,
    this.errorBuilder,
    this.appendErrorBuilder,
    this.appendLoaderBuilder,
    this.onPullToRefresh,
    this.onRetryInitial,
    this.onRetryAppend,
    this.onError,
    this.onAppendError,
    this.addAutomaticKeepAlives = true,
    this.addRepaintBoundaries = true,
    this.addSemanticIndexes = true,
    this.cacheExtent,
    this.endOfListMessage,
  }) : cubit = validateAndInitializeCubit<T>(
          cubit: cubit,
          controller: controller,
          scrollDirection: scrollDirection,
        );

  // Required by mixin
  @override
  final PaginatrixCubit<T> cubit;

  /// Function to build each item in the list.
  ///
  /// Called for each item with the item data, context, and index.
  final Widget Function(BuildContext context, T item, int index) itemBuilder;

  /// Optional function to generate unique keys for items.
  ///
  /// If provided, each item will have a key generated by this function.
  final String Function(T item, int index)? keyBuilder;

  /// Number of items from the end to trigger loading the next page.
  ///
  /// Defaults to the value from [PaginationOptions.defaultPrefetchThreshold].
  final int? prefetchThreshold;

  /// Padding around the list.
  @override
  final EdgeInsetsGeometry? padding;

  /// Scroll physics behavior.
  @override
  final ScrollPhysics? physics;

  /// Whether the list should shrink-wrap its contents.
  ///
  /// Defaults to false.
  @override
  final bool shrinkWrap;

  /// Scroll direction (vertical or horizontal).
  ///
  /// Defaults to [Axis.vertical].
  @override
  final Axis scrollDirection;

  /// Whether to reverse the scroll direction.
  ///
  /// Defaults to false.
  @override
  final bool reverse;

  /// Optional builder for separators between items.
  ///
  /// If provided, separators will be inserted between items.
  final Widget Function(BuildContext context, int index)? separatorBuilder;

  /// Custom skeleton loader builder for initial loading state.
  ///
  /// If provided, this will be used instead of the default skeletonizer.
  final Widget Function(BuildContext context, int index)? skeletonizerBuilder;

  // Mixin-required callbacks
  /// Custom widget builder for empty state.
  ///
  /// If provided, this will be used instead of the default empty view.
  @override
  final Widget Function(BuildContext context)? emptyBuilder;

  /// Custom widget builder for error state.
  ///
  /// If provided, this will be used instead of the default error view.
  @override
  final Widget Function(BuildContext context, PaginationError error)?
      errorBuilder;

  /// Custom widget builder for append error state.
  ///
  /// If provided, this will be used instead of the default append error view.
  @override
  final Widget Function(BuildContext context, PaginationError error)?
      appendErrorBuilder;

  /// Custom widget builder for loading more indicator.
  ///
  /// If provided, this will be used instead of the default append loader.
  @override
  final Widget Function(BuildContext context)? appendLoaderBuilder;

  /// Callback when user pulls to refresh.
  ///
  /// If provided, this will be called in addition to the default refresh behavior.
  @override
  final VoidCallback? onPullToRefresh;

  /// Callback for retrying initial load.
  ///
  /// If provided, this will be used instead of the default retry behavior.
  @override
  final VoidCallback? onRetryInitial;

  /// Callback for retrying append operation.
  ///
  /// If provided, this will be used instead of the default retry behavior.
  @override
  final VoidCallback? onRetryAppend;

  /// Callback when an error occurs during initial load.
  ///
  /// This is called when the state transitions to error state.
  /// Use this to show toast notifications, dialogs, or handle errors in any way you want.
  ///
  /// If not provided, errors are only shown via [errorBuilder] (no automatic notifications).
  ///
  /// **Examples:**
  ///
  /// ```dart
  /// // Using SnackBar (from ErrorNotificationHelper)
  /// onError: (context, error) {
  ///   ErrorNotificationHelper.showSnackBar(
  ///     context,
  ///     error,
  ///     isAppendError: false,
  ///     onRetry: () => _cubit.loadFirstPage(),
  ///   );
  /// },
  ///
  /// // Using Dialog
  /// onError: ErrorNotificationHelper.showErrorDialog,
  ///
  /// // Using FlutterToast (requires fluttertoast package)
  /// onError: (context, error) {
  ///   Fluttertoast.showToast(
  ///     msg: error.userMessage,
  ///     toastLength: Toast.LENGTH_LONG,
  ///   );
  /// },
  ///
  /// // Custom implementation
  /// onError: (context, error) {
  ///   showCustomNotification(context, error);
  /// },
  /// ```
  @override
  final void Function(BuildContext context, PaginationError error)? onError;

  /// Callback when an error occurs during append operation.
  ///
  /// This is called when the state transitions to appendError state.
  /// Use this to show toast notifications, dialogs, or handle append errors in any way you want.
  ///
  /// If not provided, errors are only shown via [appendErrorBuilder] (no automatic notifications).
  ///
  /// **Examples:**
  ///
  /// ```dart
  /// // Using SnackBar (from ErrorNotificationHelper)
  /// onAppendError: (context, error) {
  ///   ErrorNotificationHelper.showSnackBar(
  ///     context,
  ///     error,
  ///     isAppendError: true,
  ///     onRetry: () => _cubit.loadNextPage(),
  ///   );
  /// },
  ///
  /// // Using Bottom Sheet
  /// onAppendError: ErrorNotificationHelper.showBottomSheet,
  ///
  /// // Using FlutterToast
  /// onAppendError: (context, error) {
  ///   Fluttertoast.showToast(
  ///     msg: 'Failed to load more: ${error.userMessage}',
  ///     toastLength: Toast.LENGTH_SHORT,
  ///   );
  /// },
  /// ```
  @override
  final void Function(BuildContext context, PaginationError error)?
      onAppendError;

  /// Custom message to display when there are no more items to load.
  ///
  /// If not provided, defaults to "No more items to load".
  @override
  final String? endOfListMessage;

  // ListView performance options
  /// Whether to add automatic keep-alives to list items.
  ///
  /// Defaults to true.
  @override
  final bool addAutomaticKeepAlives;

  /// Whether to add repaint boundaries to list items.
  ///
  /// Defaults to true.
  @override
  final bool addRepaintBoundaries;

  /// Whether to add semantic indexes to list items.
  ///
  /// Defaults to true.
  @override
  final bool addSemanticIndexes;

  /// Cache extent for the scroll view.
  ///
  /// Controls how much content is kept in memory off-screen.
  @override
  final double? cacheExtent;

  // build() method is now in the mixin

  @override
  Widget buildLoadingState(BuildContext context) {
    final builder = skeletonizerBuilder;
    if (builder != null) {
      return createCustomScrollView(
        slivers: [
          SliverList(
            delegate: createSliverDelegate(
              builder: builder,
              childCount: PaginatrixSkeletonConstants.defaultItemCount,
            ),
          ),
        ],
      );
    }

    // Use PaginatrixSkeletonizer which handles its own CustomScrollView
    return PaginatrixSkeletonizer(
      padding: padding,
      physics: physics,
      shrinkWrap: shrinkWrap,
      scrollDirection: scrollDirection,
      reverse: reverse,
    );
  }

  @override
  Widget buildScrollableContent(
      BuildContext context, PaginationState<T> state) {
    final items = state.items;
    final itemCount = items.length;
    final hasMore = state.canLoadMore;
    final isAppending = state.status.maybeWhen(
      appending: () => true,
      orElse: () => false,
    );
    final hasAppendError = state.hasAppendError;
    final hasSeparator = separatorBuilder != null;

    return createScrollListener(
      prefetchThreshold: prefetchThreshold,
      reverse: reverse,
      child: createCustomScrollView(
        slivers: [
          SliverList(
            delegate: createSliverDelegate(
              builder: (context, index) {
                if (hasSeparator && index > 0) {
                  // Return separator before item (except first item)
                  final separator = separatorBuilder;
                  if (separator == null) {
                    return buildItem(
                        context, items[index], index, itemBuilder, keyBuilder);
                  }
                  return Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      separator(context, index - 1),
                      buildItem(context, items[index], index, itemBuilder,
                          keyBuilder),
                    ],
                  );
                }
                return buildItem(
                    context, items[index], index, itemBuilder, keyBuilder);
              },
              childCount: itemCount,
            ),
          ),
          // Show footer when:
          // 1. Appending or has error (with items or more pages)
          // 2. No more data but we have items (show "end of list" message)
          if (((isAppending || hasAppendError) && (itemCount > 0 || hasMore)) ||
              (!hasMore && itemCount > 0 && !isAppending && !hasAppendError))
            SliverToBoxAdapter(
              child: buildFooterItem(
                context,
                hasMore: hasMore,
                isAppending: isAppending,
                hasAppendError: hasAppendError,
                state: state,
              ),
            ),
        ],
      ),
    );
  }
}
